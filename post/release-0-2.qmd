---
title: "GeoArrow 0.2 Release"
---

We released the first version of the GeoArrow specification (0.1) in September, 2023.
Since then we've learned from the [numerous integrations](#ecosystem)
implemented by ourselves and others in the spatial community that highlighted
ambiguities in the text of the first version and use-cases that necessitated
changes to the specification. In this post we highlight new updates to the
specification, updates to implementations, and community-driven integrations
since the last specification release.

## Specification

The GeoArrow specification establishes conventions for representing spatial data
in [Apache Arrow](https://arrow.apache.org) formats (e.g., C Data Interface,
Serialized IPC) and implementations (e.g., PyArrow, Arrow C++, arrow-rs).
It is separated into two parts:

- A set of [extension type](https://geoarrow.org/extension-types.html) definitions
  to propagate type-level spatial metadata (e.g., coordinate reference system, edge interpolation)
- A set of [memory layouts](https://geoarrow.org/format.html) to represent geometry
  arrays using features of the Arrow type system/format (e.g., points can be
  represented as a `struct<x: double, y: double>`) instead of serialized into
  well-known binary or some other binary format.

In addition to some minor updates to improve clarity, GeoArrow 0.2 includes three
notable changes.

First, the language defining the content of the `"crs"` key in the extension metadata
was updated to simplify the dependency requirements of producers that did not have
a built-in ability to produce
[PROJJSON](https://proj.org/en/stable/specifications/projjson.html), which was
previously the only option allowed by the specification.

- Box type
- Geometry Union

## Rust

- https://geoarrow.org/geoarrow-rs

Supports new types, metadata and ...?

## C/C++

- https://geoarrow.org/geoarrow-c
- Supports new types, metadata
- Cleaned up/simplified interface

TODO:

- Import geometry union type

## Python

- https://geoarrow.org/geoarrow-python
- https://geoarrow.org/geoarrow-rs/python

The Initial [geoarrow-pyarrow](https://github.com/geoarrow/geoarrow-python) implementation
depended completely on geoarrow's C implementation for almost everything; however it quickly
became clear that a [PyArrow](https://arrow.apache.org/docs/python/)-native implementation
was what potential importers/exporters of GeoArrow in Python were actually looking for.
The result was two packages:

- `geoarrow-types`, which provides an pure Python implementation of the GeoArrow
  type system and PyArrow-native extension type implementation.
- `geoarrow-pyarrow`, which provides compute functions and IO tools that
  use PyArrow data structures for input/output but use various GeoArrow implementations
  under the hood to do the actual crunching.

The changes since the 0.1 release were mostly structure; however new spec features were
also added including support for the box type and support for non-PROJJSON CRS encodings.

Example ...

Whereas `geoarrow-pyarrow` and `geoarrow-types` are aimed squarely at the PyArrow
ecosystem, [`geoarrow-rust`](https://geoarrow.org/geoarrow-rs/python) provides a
feature-rich set of compute and IO functions with input/output based on
the [Arrow PyCapsule Interface](https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html).

...

## R

- https://geoarrow.org/geoarrow-r
- https://github.com/JosiahParry/geoarrowrs

TODO:

- All new types, metadata (easier when geoarrow-c supports it)

## Data

GeoArrow's 0.2 series of releases includes brand new revamped example data, the
pipeline for which was completely rewritten to be mostly in Python using
[geoarrow-rs](https://github.com/geoarrow/geoarrow-rs)'s excellent Python bindings,
[geoarrow-python](https://github.com/geoarrow/geoarrow-python),
[geopandas](https://geopandas.org), and
[duckdb-spatial](https://duckdb.org/docs/extensions/spatial). The new pipeline
made it easier to generate more formats and more examples to cover some of the
concepts highlighted by our first year of on-the-ground experience with the format.
A few highlights include:

- Most examples are now available in [FlatGeoBuf](https://flatgeobuf.org),
  [GeoParquet](https://geoparquet.org)'s WKB and Native encodings,
  [Parquet's brand-new GEOMETRY logical type](https://cloudnativegeo.org/blog/2025/02/geoparquet-2.0-going-native/),
  and GeoArrow IPC streams with the WKT, WKB, native/interleaved, and
  native/separated encodings where appropriate.
- [Coordinate Reference System (CRS) examples](https://github.com/geoarrow/geoarrow-data/blob/main/example-crs#readme)
  were added to cover various CRS encodings and categories that implementations may wish
  to consider.
- [USGS Map Quadrangles](https://github.com/geoarrow/geoarrow-data/tree/main/quadrangles#readme)
  were added to illustrate the utility of/test the new "box" encoding that was added in the
  0.2 release.
- [Several examples](https://github.com/geoarrow/geoarrow-data/blob/main/natural-earth#readme)
  based on the [Natural Earth](https://www.naturalearthdata.com/) project were added, including
  an example with spherical edges/geography data type that can be used as a basic
  example to illustrate/test global data handling.

The latest data is available from the [geoarrow.org data page](https://geoarrow.org/data)
and the sources can be found at the
[geoarrow/geoarrow-data](https://github.com/geoarrow/geoarrow-data) GitHub repository.

## Ecosystem

### GeoPandas

In the landmark [GeoPandas](https://geopandas.org) 1.0 release, the `GeoSeries` and `GeoDataFrame`
added `from_arrow()` and `to_arrow()` methods to import and export Python objects using the
[Arrow PyCapsule Interface](https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html).

```python
import pyarrow as pa
import geoarrow.pyarrow as ga
from geoarrow.rust.io import read_flatgeobuf
import geopandas

url = "https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0-rc6/natural-earth/files/natural-earth_cities.fgb"

table_rs = read_flatgeobuf(url)
df = geopandas.GeoDataFrame.from_arrow(table_rs)
df.head(5)
#>            name                   geometry
#> 0  Vatican City  POINT (12.45339 41.90328)
#> 1    San Marino   POINT (12.44177 43.9361)
#> 2         Vaduz   POINT (9.51667 47.13372)
#> 3       Lobamba     POINT (31.2 -26.46667)
#> 4    Luxembourg      POINT (6.13 49.61166)

pa.table(df.to_arrow())
#> pyarrow.Table
#> name: string
#> geometry: extension<geoarrow.wkb<WkbType>>
#> ----
#> name: [["Vatican City","San Marino","Vaduz","Lobamba","Luxembourg",...,
#> geometry: [[010100000054E57B4622E828408B074AC09EF34440,0101000000DC...
```

For more information, see the excellent GeoPandas documentation:

- [`GeoSeries.from_arrow()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.from_arrow.html)
- [`GeoSeries.to_arrow()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.to_arrow.html)
- [`GeoDataFrame.from_arrow()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.from_arrow.html)
- [`GeoDataFrame.to_arrow()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_arrow.html)

Thanks to [@jorisvandenbossche](https://github.com/jorisvandenbossche) and
[@kylebarron](https://github.com/kylebarron), for driving this integration!

### Lonboard

What's a fast geospatial skateboard? A *lon*board, of course! Powered by
[deck.gl](https://deck.gl/), [lonboard](https://github.com/developmentseed/lonboard)
can effortlessly render millions of features on an interactive map. The rendering
is powered by [GeoArrow's native encodings](https://geoarrow.org/format.html) and
the [GeoArrow extension types](https://geoarrow.org/extension-types.html) power
geometry column detection and on-the-fly reprojection to ensure multiple layers are
plotted together properly. The `viz()` one-liner works on any
[Arrow-ish Python object](https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html)
and is a massive quality-of-life improvement when working with large-ish data in a notebook.

```python
from geoarrow.rust.io import read_flatgeobuf
from lonboard import viz

url = "https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0-rc6/natural-earth/files/natural-earth_cities.fgb"
viz(read_flatgeobuf(url))
```

![](release-0-2-lonboard.png)

All credit here to [@kylebarron](https://github.com/kylebarron) for creating and maintaining
this tool!

### DuckDB

It has [long been a confusion](https://github.com/duckdb/duckdb-spatial/issues/153)
for users of DuckDB's fantastic [spatial extension](https://duckdb.org/docs/extensions/spatial)
that a query like `SELECT st_geomfromtext('LINESTRING (0 1, 2 3)')`, when converted to PyArrow
or R's arrow package, contains no indication of any geometry column. The column that does
appear in the output contains DuckDB spatial's internal serialization and is in general not
that useful.

In DuckDB 1.2, core developers
[added support for extensions to control Arrow import/export](https://github.com/duckdb/duckdb/pull/15285),
which opened the door for the spatial extension to
[accept GeoArrow extensions](https://github.com/duckdb/duckdb-spatial/pull/485)
and roundtrip the geometry type through DuckDB's much used Arrow integration in
Python, R, and ADBC. Among other libraries supporting GeoArrow, this powers seamless
integration between GeoPandas and DuckDB.

```python
import geopandas
import duckdb

duckdb.load_extension("spatial")
duckdb.sql("CALL register_geoarrow_extensions()")

# Create a GeoDataFrame
url = "https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0-rc6/natural-earth/files/natural-earth_cities.fgb"
df = geopandas.read_file(url)

# Create the Arrow table and use select directly from it with DuckDB
df_arrow = df.to_arrow()
duckdb.sql("SELECT * FROM df_arrow").limit(5)
#> ┌──────────────┬────────────────────────────────┐
#> │     name     │            geometry            │
#> │   varchar    │            geometry            │
#> ├──────────────┼────────────────────────────────┤
#> │ Vatican City │ POINT (12.4533865 41.9032822)  │
#> │ San Marino   │ POINT (12.4417702 43.9360958)  │
#> │ Vaduz        │ POINT (9.5166695 47.1337238)   │
#> │ Lobamba      │ POINT (31.1999971 -26.4666675) │
#> │ Luxembourg   │ POINT (6.1300028 49.6116604)   │
#> └──────────────┴────────────────────────────────┘

# Going the other direction, call from_arrow() directly on a DuckDB result
geopandas.GeoDataFrame.from_arrow(duckdb.sql("SELECT * FROM df_arrow")).head(5)
#>            name                   geometry
#> 0  Vatican City  POINT (12.45339 41.90328)
#> 1    San Marino   POINT (12.44177 43.9361)
#> 2         Vaduz   POINT (9.51667 47.13372)
#> 3       Lobamba     POINT (31.2 -26.46667)
#> 4    Luxembourg      POINT (6.13 49.61166)
```

For several more examples and a deeper dive in to DuckDB spatial in Python, see
[Max Gabrielsson's excellent GeoPython 2025 tutorial](https://github.com/Maxxen/Geopython25).

Special thanks to [@Maxxen](https://github.com/Maxxen), [@pdet](https://github.com/pdet),
and [@ianmcook](https://github.com/ianmcook) for the PRs, reviews, and coordination to get
this feature over the finish line!

### Apache Sedona

Apache Sedona's 1.6.0 release
[added `dataframe_to_arrow()`](https://github.com/apache/sedona/pull/1767)
in its Python bindings and its 1.7.0 release added an
[Arrow-powered `create_spatial_dataframe()`](https://github.com/apache/sedona/pull/1825)
creator to accellerate the Sedona--GeoPandas integration. In addition to higher
performance when converting between GeoPandas and Spark, this change accellerated
visualization of Spark `DataFrame`s with Geometry and general integration
with tools that support GeoArrow.

```python
import geopandas
import lonboard
from sedona.spark import SedonaContext
from sedona.utils.geoarrow import create_spatial_dataframe, dataframe_to_arrow

url = "https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0-rc6/natural-earth/files/natural-earth_cities.fgb"
df = geopandas.read_file(url)

config = SedonaContext.builder().getOrCreate()
sedona = SedonaContext.create(config)

sedona_df = create_spatial_dataframe(sedona, df)
sedona_df.printSchema()
#> root
#>  |-- name: string (nullable = true)
#>  |-- geometry: geometry (nullable = true)

lonboard.viz(dataframe_to_arrow(sedona_df))
```

![](release-0-2-lonboard.png)

These integrations were made possible by backporting the
[forthcoming toArrow() in Spark 4.0](https://github.com/apache/spark/pull/45481)
and the forthcoming ability of `createDataFrame()` to
[accept Arrow objects directly](https://github.com/apache/spark/pull/46529).

Thanks to [@ianmcook](https://github.com/ianmcook) for driving these changes
in the Spark project and thanks to [@jiayuasu](https://github.com/jiayuasu) and
[@Imbruced](https://github.com/Imbruced) for reviewing/integrating these changes
into Sedona!

### GDAL

GDAL added its first [Arrow integration in RFC 86](https://gdal.org/en/stable/development/rfc/rfc86_column_oriented_api.html). This integration added a C API to work around the performance limitations of OGR's row-based reader and was picked up by [pyogrio](https://github.com/geopandas/pyogrio) almost immediately to enable faster IO - particularly for GeoPackage and FlatGeoBuf - for geopandas users. About a year later [a matching write API was added](https://github.com/OSGeo/gdal/pull/8517) and was used by GDAL itself to [speed up](https://github.com/OSGeo/gdal/pull/8560) its popular `ogr2ogr` command-line interface.

Specifically related to the GeoArrow specification, GDAL 3.8.0 included the ability to
[export geometry through its Arrow interface with GeoArrow type and CRS metadata](https://github.com/OSGeo/gdal/pull/8617).
This makes it substantially easier to propagate the CRS of a geometry column when
using OGR's `GetArrowStream()` interface by passing the `GEOMETRY_METADATA_ENCODING=GEOARROW`
layer option. When this option is set, geometry columns are marked with the `geoarrow.wkb`
extension type with the appropriate `"crs"` in the extension metadata.

Full credit to [@rouault](https://github.com/rouault) for implementing these changes in
the GDAL project!

### Ibis

https://github.com/ibis-project/ibis/pull/9549

## What's next?

- Discrete global grids
- Raster
