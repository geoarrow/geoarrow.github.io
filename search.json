[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Fast, Elegant, and Performative Geospatial Data Analysis with Arrow (Kae Suarez, Dewey Dunnington: Voltron Data Blog)"
  },
  {
    "objectID": "resources.html#blog-posts",
    "href": "resources.html#blog-posts",
    "title": "Resources",
    "section": "",
    "text": "Fast, Elegant, and Performative Geospatial Data Analysis with Arrow (Kae Suarez, Dewey Dunnington: Voltron Data Blog)"
  },
  {
    "objectID": "format.html",
    "href": "format.html",
    "title": "Format",
    "section": "",
    "text": "Spatial information can be represented as a collection of discrete objects using points, lines, and polygons (i.e., vector data). The Simple Feature Access standard provides a widely used abstraction, defining a set of geometries: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection. Next to a geometry, simple features can also have non-spatial attributes that describe the feature.\nThe Apache Arrow project specifies a standardized language-independent columnar memory format. It enables shared computational libraries, zero-copy shared memory and streaming messaging, interprocess communication, etc and is supported by many programming languages. The Arrow columnar memory model is suited to store both vector features and their attribute data. This document specifies how such vector features can be stored in Arrow (and Arrow-compatible) data structures.\nThe terminology for array types in this document is based on the Arrow Columnar Format specification."
  },
  {
    "objectID": "format.html#native-encoding",
    "href": "format.html#native-encoding",
    "title": "Format",
    "section": "Native encoding",
    "text": "Native encoding\n\nMotivation\nStandard ways to represent or serialize vector geometries include WKT (e.g., “POINT (0 0)”), WKB and GeoJSON. Each of those representations have a considerable (de)serialization cost, neither do they have a compute-friendly memory layout.\nThe goal of this specification is to store geometries in an Arrow-compatible format that:\n\nHas low (de)serialization overhead, and\nOnce in memory is cheap to convert to geospatial libraries (e.g., GEOS or JTS) or easy to directly operate on (e.g., directly working with the coordinate values).\n\nBenefits of using the proposed Arrow-native format include:\n\nCheap access to the raw coordinate values for all geometries,\nColumnar data layout, and\nFull data type system of Arrow is available for attribute data.\n\nMore specifically, the Arrow geometry specification stores the raw coordinate values in contiguous buffers with enough metadata (offsets) to reconstruct or interpret them as actual geometries.\nFlatGeoBuf is similar on various aspects, but is record-oriented, whereas Arrow is column-oriented.\n\n\nMemory layouts\nGeoArrow proposes a packed columnar data format for the fundamental geometry types using packed coordinate and offset arrays to define geometry objects.\nThe inner level is always an array of coordinates. For any geometry type except Point, this inner level is nested in one or multiple variable sized list arrays. In practice, this means we have additional arrays storing the offsets that denote where a new geometry, a new geometry part, or a new polygon ring starts.\nThis specification supports coordinates encoded as a Struct array storing the coordinate values as separate arrays (i.e., x: [x, x, ...], y: [y, y, y, ...]) and a FixedSizeList of interleaved values (i.e., [x, y, x, y, ...]). As implementations evolve, this specification may grow to support other coordinate representations or shrink to support only one if supporting multiple representations becomes a barrier to adoption.\nCoordinate (separated): Struct&lt;x: double, y: double, [z: double, [m: double&gt;]]\nAn array of coordinates can be stored as a Struct array containing two or more child double arrays with names corresponding to the dimension represented by the child. The first and second child arrays must represent the x and y dimension; where z and m dimensions are both included, the z dimension must preceed the m dimension.\nCoordinate (interleaved): FixedSizeList&lt;double&gt;[n_dim]\nAn array of coordinates may also be represented by a single array of interleaved coordinates. n_dim can be 2, 3, or 4 depending on the dimensionality of the geometries, and the field name of the list should be “xy”, “xyz” or “xyzm”, reflecting the dimensionality. Compared to the Struct representation of a coordinate array, this representation may provide better performance for some operations and/or provide better compatability with the memory layout of existing libraries.\nPoint: Coordinate\nAn array of point geometries is represented as an array of coordinates, which may be encoded according to either of the options above.\nLineString: List&lt;Coordinate&gt;\nAn array of LineStrings is represented as a nested list array with one level of outer nesting: each element of the array (LineString) is a list of xy vertices. The child name of the outer list should be “vertices”.\nPolygon: List&lt;List&lt;Coordinate&gt;&gt;\nAn array of Polygons is represented as a nested list array with two levels of outer nesting: each element of the array (Polygon) is a list of rings (the first ring is the exterior ring, optional subsequent rings are interior rings), and each ring is a list of xy vertices. The child name of the outer list should be “rings”; the child name of the inner list should be “vertices”. The first coordinate and the last coordinate of a ring must be identical (i.e., rings must be closed).\nMultiPoint: List&lt;Coordinate&gt;\nAn array of MultiPoints is represented as a nested list array, where each outer list is a single MultiPoint (i.e. a list of xy coordinates). The child name of the outer List should be “points”.\nMultiLineString: List&lt;List&lt;Coordinate&gt;&gt;\nAn array of MultiLineStrings is represented as a nested list array with two levels of outer nesting: each element of the array (MultiLineString) is a list of LineStrings, which consist itself of a list xy vertices (see above). The child name of the outer list should be “linestrings”; the child name of the inner list should be “vertices”.\nMultiPolygon: List&lt;List&lt;List&lt;Coordinate&gt;&gt;&gt;\nAn array of MultiPolygons is represented as a nested list array with three levels of outer nesting: each element of the array (MultiPolygon) is a list of Polygons, which consist itself of a list of rings (the first ring is the exterior ring, optional subsequent rings are interior rings), and each ring is a list of xy vertices. The child name of the outer list should be “polygons”; the child name of the middle list should be “rings”; the child name of the inner list should be “vertices”.\n\n\nMissing values (nulls)\nArrow supports missing values through a validity bitmap, and for nested data types every level can be nullable. For this specification, only the outer level is allowed to have nulls, and all other levels (including the inner level with the actual coordinate values) should not contain any nulls. Those fields can be marked explicitly as non-nullable, but this is not required.\nIn practice this means you can have a missing geometry, but not a geometry with a null part or null (co)ordinate (for example, a polygon with a null ring or a point with a null x value).\n\n\nEmpty geometries\nExcept for Points, empty geometries can be faithfully represented as an empty outer list.\nEmpty points can be represented as POINT (NaN NaN).\n\n\nGeometryCollection\nGeometryCollection features cannot yet be represented using a native encoding. Future support is planned using an Arrow union type.\nGeometryCollection features can be represented using a serialized encoding (WKB or WKT), see below.\n\n\nMixed Geometry types\nArrays containing features of mixed geometry types cannot yet be represented using a native encoding. Future support is planned using an Arrow union type.\nNote that single and multi geometries of the same type can be stored together in a Multi encoding. For example, a mix of Polygon and MultiPolygon can be stored as MultiPolygons, with a Polygon being represented as a length-1 MultiPolygon.\nArrays with mixed geometry types can be represented using a serialized encoding (WKB or WKT), see below.\n\n\nField and child names\nAll geometry types should have field and child names as suggested for each; however, implementations must be able to ingest arrays with other names when the interpretation is unambiguous (e.g., for xy and xyzm interleaved coordinate interpretations)."
  },
  {
    "objectID": "format.html#serialized-encodings",
    "href": "format.html#serialized-encodings",
    "title": "Format",
    "section": "Serialized encodings",
    "text": "Serialized encodings\nWhereas there are many advantages to storing data in the native encoding, many producers of geospatial data (e.g., database drivers, file readers) do not have a full geospatial stack at their disposal. The serialized encodings are provided to accomodate these producers and provide every opportunity to propagate critical metadata (e.g., CRS).\nWell-known binary (WKB): Binary or LargeBinary\nIt may be useful for implementations that already have facilities to read and/or write well-known binary (WKB) to store features in this form without modification. For maximum compatibility producers should write ISO-flavoured WKB where possible; however, consumers may accept EWKB or ISO flavoured WKB. Consumers may ignore any embedded SRID values in EWKB.\nThe Arrow Binary type is composed of two buffers: a buffer of int32 offsets and a uint8 data buffer. The LargeBinary type is composed of an int64 offset buffer and a uint8 data buffer.\nWell-known text (WKT): Utf8 or LargeUtf8\nIt may be useful for implementations that already have facilities to read and/or write well-known text (WKT) to store features in this form without modification.\nThe Arrow Utf8 type is composed of two buffers: a buffer of int32 offsets and a char data buffer. The LargeUtf8 type is composed of an int64 offset buffer and a char data buffer."
  },
  {
    "objectID": "format.html#concrete-examples-of-the-memory-layout",
    "href": "format.html#concrete-examples-of-the-memory-layout",
    "title": "Format",
    "section": "Concrete examples of the memory layout",
    "text": "Concrete examples of the memory layout\nPoint\nArrow type: FixedSizeList&lt;double&gt;[2] or Struct&lt;x: double, y: double&gt;\nFor an array of Point geometries, only a single coordinate array is used. If using a fixed size list coordinate representation, each Point will consist of 2 coordinate values and a single array of length 2*N is sufficiently informative. If using a struct coordinate representation, there will be one child array per dimension.\nExample of array with 3 points:\nWKT: [\"POINT (0 0)\", \"POINT (0 1)\", \"POINT (0 2)\"]\nLogical representation:\n[(0, 0), (0, 1), (0, 2)]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0]\n\nIf using a struct coordinate representation:\n\nCoordinate x values: [0.0, 0.0, 0.0]\nCoordinate y values: [0.0, 1.0, 2.0]\n\nMultiPoint\nArrow type: List&lt;FixedSizeList&lt;double&gt;[2]&gt; or List&lt;Struct&lt;x: double, y: double&gt;&gt;\nFor an array of MultiPoint geometries, an additional array of offsets indicate where the vertices of each MultiPoint start.\nExample of array with 3 multipoints:\nWKT: [\"MULTIPOINT (0 0, 0 1, 0 2)\", \"MULTIPOINT (1 0, 1 1)\", \"MULTIPOINT (2 0, 2 1, 2 2)\"]\nLogical representation:\n[\n    [(0.0, 0.0), (0.0, 1.0), (0.0, 2.0)],\n    [(1.0, 0.0), (1.0, 1.0)],\n    [(2.0, 0.0), (2.0, 1.0), (2.0, 2.0)]\n]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 2.0]\nGeometry offsets: [0, 3, 5, 8]\n\nFor an interleaved coordinate representation, the coordinates buffer must contain the number of geometry offsets * 2 elements. If using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nMultiLineString\nArrow type: List&lt;List&lt;FixedSizeList&lt;double&gt;[2]&gt;&gt; or List&lt;List&lt;Struct&lt;x: double, y: double&gt;&gt;&gt;\nExample of array with 3 multilines:\nWKT:\n[\n    \"LINESTRING (0 0, 0 1, 0 2)\",\n    \"MULTILINESTRING ((1 0, 1 1), (2 0, 2 1, 2 2))\",\n    \"LINESTRING (3 0, 3 1)\"\n]\nLogical representation:\n[\n    [[(0, 0), (0, 1), (0, 2)]],\n    [\n        [(1, 0), (1, 1)],\n        [(2, 0), (2, 1), (2, 2)]\n    ],\n    [[(3, 0), (3, 1)]],\n]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 2.0, 3.0, 0.0, 3.0, 1.0]\nPart offsets (linestrings): [0, 3, 5, 8, 10]\nGeometry offsets: [0, 1, 3, 4]\n\nIf using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nMultiPolygon\nArrow type: List&lt;List&lt;List&lt;FixedSizeList&lt;double&gt;[2]&gt;&gt;&gt; or List&lt;List&lt;List&lt;Struct&lt;x: double, y: double&gt;&gt;&gt;&gt;\nExample of array with 3 points:\nWKT:\n[\n    \"MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))\",\n    \"POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))\",\n    \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)))\"\n]\nLogical representation:\n[\n    # MultiPolygon 1\n    [\n        [\n            [[40, 40], [20, 45], [45, 30], [40, 40]]\n        ],\n        [\n            [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]],\n            [[30, 20], [20, 15], [20, 25], [30, 20]]\n        ]\n    ],\n    # MultiPolygon 2 (using an additional level of nesting to turn the Polygon into a MultiPolygon with one part)\n    [\n        [\n            [[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]\n        ]\n    ],\n    # MultiPolygon 3\n    [\n        [\n            [[30, 20], [45, 40], [10, 40], [30, 20]]\n        ],\n        [\n            [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n        ]\n    ]\n]\nPhysical representation (buffers):\n\nCoordinates: [40.0, 40.0, 20.0, 45.0, 45.0, 30.0, 40.0, 40.0, 20.0, 35.0, 10.0, 30.0, 10.0, 10.0, 30.0, 5.0, 45.0, 20.0, 20.0, 35.0, 30.0, 20.0, 20.0, 15.0, 20.0, 25.0, 30.0, 20.0, 30.0, 10.0, 40.0, 40.0, 20.0, 40.0, 10.0, 20.0, 30.0, 10.0, 30.0, 20.0, 45.0, 40.0, 10.0, 40.0, 30.0, 20.0, 15.0, 5.0, 40.0, 10.0, 10.0, 20.0, 5.0, 10.0, 15.0, 5.0]\nRing offsets: [0, 4, 10, 14, 19, 23, 28]\nPart offsets (polygons): [0, 1, 3, 4, 5, 6]\nGeometry offsets: [0, 2, 3, 5]\n\nIf using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nWKT\nArrow type: Utf8\nFor an array of WKT geometries, a buffer of offsets indicate where the text of each feature begins.\nExample of array with 2 features:\nWKT: [\"MULTIPOINT (0 0, 0 1)\", \"POINT (30 10)\"]\nLogical representation:\n[\n    \"MULTIPOINT (0 0, 0 1)\",\n    \"POINT (30 10)\"\n]\nPhysical representation (buffers):\n\nData: b\"MULTIPOINT (0 0, 0 1)POINT (30 10)\"\nFeature offsets: [0, 21, 46]"
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data",
    "section": "",
    "text": "The Nova Scotia Water data set (i.e., the Nova Scotia Hydrographic Network) and supporting data are provided by the Nova Scotia Geospatial Data Directory.\nThese data were obtained under an Unrestricted Data Use License Agreement for Government Geographic Data as specified by the Province of Nova Scotia Geospatial Data Directory.\n\n\n\n\nbasin_line (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nbasin_point (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nbasin_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nland_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_cent (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_junc (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_line (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_point (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)"
  },
  {
    "objectID": "data.html#nova-scotia-water",
    "href": "data.html#nova-scotia-water",
    "title": "Data",
    "section": "",
    "text": "The Nova Scotia Water data set (i.e., the Nova Scotia Hydrographic Network) and supporting data are provided by the Nova Scotia Geospatial Data Directory.\nThese data were obtained under an Unrestricted Data Use License Agreement for Government Geographic Data as specified by the Province of Nova Scotia Geospatial Data Directory.\n\n\n\n\nbasin_line (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nbasin_point (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nbasin_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nland_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_cent (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_junc (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_line (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_point (fgb/zip, arrow, arrow/interleaved, arrow/wkb)\nwater_poly (fgb/zip, arrow, arrow/interleaved, arrow/wkb)"
  },
  {
    "objectID": "data.html#microsoft-u.s.-building-footprints",
    "href": "data.html#microsoft-u.s.-building-footprints",
    "title": "Data",
    "section": "Microsoft U.S. Building Footprints",
    "text": "Microsoft U.S. Building Footprints\nThe Microsoft U.S. Building Footprints data set is a collection of ~130 million polygon outlines of buildings derived from satellite imagery. The version of the data set in this repository is does not include Alaska or Hawaii, is repackaged as a single point for each building, and compressed using ZSTD compression to minimize file size and facilitate downloading.\nThe original data is licensed under the Open Data Commons Open Database License (ODbL) and is made available here under the same license.\n\n\nFiles\n\npoint (fgb/zip, arrow, arrow/interleaved)"
  },
  {
    "objectID": "data.html#examples",
    "href": "data.html#examples",
    "title": "Data",
    "section": "Examples",
    "text": "Examples\nThese files are toy example files useful for testing and simple examples. Their main purpose is to make it easy to test full coverage of the geometry type/dimension/coordinate type grid. The examples are based on the wk R package’s wk::wk_example_wkt data set.\n\n\nFiles\n\npoint (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nlinestring (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npolygon (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipoint (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultilinestring (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipolygon (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npoint_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nlinestring_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npolygon_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipoint_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultilinestring_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipolygon_z (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npoint_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nlinestring_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npolygon_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipoint_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultilinestring_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipolygon_m (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npoint_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nlinestring_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\npolygon_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipoint_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultilinestring_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)\nmultipolygon_zm (gpkg, arrow, arrow/interleaved, arrow/wkt, arrow/wkb)"
  },
  {
    "objectID": "extension-types.html",
    "href": "extension-types.html",
    "title": "Metadata",
    "section": "",
    "text": "The memory layout specification provides an encoding for geometry types using the Arrow Columnar format; however, it does not provide a route by which columns can be recognized as geometry columns when interacting with Arrow bindings (e.g., Arrow C++, PyArrow, or the arrow package for R). Similarly, it does not provide a route by which geometry metadata (e.g., coordinate reference system) can be attached at the column level. Whereas the GeoParquet metadata standard defines table-level metadata intended for geospatial-aware consumers of a file, this specification defines Array-level metadata intended for geospatial-aware consumers of individual Arrays (e.g., a library implementing a geospatial algorithm) or for non-geospatial aware consumers of a table containing such an Array (e.g., a compute engine that can select columns and/or filter rows).\nArrow’s concept of extension types allows types with additional semantics to be built on top of a built-in Arrow data type. Extension types are implemented using two metadata fields: ARROW:extension:name and ARROW:extension:metadata. Whereas the built-in Arrow data types used to store geometry is defined in the memory format specification, this document specifies how the name and metadata should be set to communicate additional information."
  },
  {
    "objectID": "extension-types.html#extension-names",
    "href": "extension-types.html#extension-names",
    "title": "Metadata",
    "section": "Extension names",
    "text": "Extension names\nWhen GeoArrow-encoded Arrays have the ARROW:extension:name metadata field set, it should be set to one of geoarrow.point, geoarrow.linestring, geoarrow.polygon, geoarrow.multipoint, geoarrow.multilinestring, geoarrow.multipolygon, geoarrow.wkb, or geoarrow.wkt. These names correspond to the memory layouts and value constraints described in GeoArrow memory layout specification; however, it should be noted that for each extension name there may be more than one concrete memory layout. The ARROW:extension:name and ARROW:extension:metadata metadata fields must only be set for the Array at the top level (i.e., child arrays must not carry an extension name or metadata)."
  },
  {
    "objectID": "extension-types.html#extension-metadata",
    "href": "extension-types.html#extension-metadata",
    "title": "Metadata",
    "section": "Extension metadata",
    "text": "Extension metadata\nWhen GeoArrow-encoded Arrays have the ARROW:extension:metadata metadata field set, it must be seriaized as a UTF-8 encoded JSON object. The following keys in the JSON metadata object are supported:\n\ncrs: A JSON object describing the coordinate reference system (CRS) using PROJJSON. This key can also be omitted if the producer does not have any information about the CRS. Note that regardless of the axis order specified by the CRS, axis order will be interpreted according to the wording in the GeoPackage WKB binary encoding: axis order is always (longitude, latitude) and (easting, northing) regardless of the the axis order encoded in the CRS specification.\nedges: A value of \"spherical\" instructs consumers that edges follow a spherical path rather than a planar one. If this value is omitted, edges will be interpreted as planar. This metadata key is only applicable to a geoarrow.linestring, geoarrow.polygon, geoarrow.multilinestring, geoarrow.multipolygon or geoarrow.wkb array and should be omitted for an Array with any other extension name.\n\nIf all metadata keys are omitted, the ARROW:extension:metadata should also be omitted."
  },
  {
    "objectID": "extension-types.html#concrete-examples-of-extension-type-metadata",
    "href": "extension-types.html#concrete-examples-of-extension-type-metadata",
    "title": "Metadata",
    "section": "Concrete examples of extension type metadata",
    "text": "Concrete examples of extension type metadata\nPoint without CRS\nStorage type without extension: FixedSizeList&lt;xy: double&gt;[2]\nThe metadata for the outer array would be as follows:\n\nARROW:extension:name: geoarrow.point\n\nLineString with CRS\nStorage type without extension: List&lt;vertices: FixedSizeList&lt;xy: double&gt;[2]&gt;\nThe metadata for the outer array would be as follows:\n\nARROW:extension:name: geoarrow.linestring\nARROW:extension:metadata: {\"crs\": {\"$schema\":\"https://proj.org/schemas/v0.4/projjson.schema.json\",\"type\":\"GeographicCRS\",\"name\":\"WGS 84\",\"datum\":{\"type\":\"GeodeticReferenceFrame\",\"name\":\"World Geodetic System 1984\",\"ellipsoid\":{\"name\":\"WGS 84\",\"semi_major_axis\":6378137,\"inverse_flattening\":298.257223563},\"id\":{\"authority\":\"EPSG\",\"code\":6326}},\"coordinate_system\":{\"subtype\":\"ellipsoidal\",\"axis\":[{\"name\":\"Longitude\",\"abbreviation\":\"lon\",\"direction\":\"east\",\"unit\":\"degree\"},{\"name\":\"Latitude\",\"abbreviation\":\"lat\",\"direction\":\"north\",\"unit\":\"degree\"}]}}}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GeoArrow",
    "section": "",
    "text": "This repository contains a specification for storing geospatial data in Apache Arrow and Arrow-compatible data structures and formats.\nThe Apache Arrow project specifies a standardized language-independent columnar memory format. It enables shared computational libraries, zero-copy shared memory and streaming messaging, interprocess communication, and is supported by many programming languages and data libraries.\nSpatial information can be represented as a collection of discrete objects using points, lines and polygons (i.e., vector data). The Simple Feature Access standard provides a widely used abstraction, defining a set of geometries: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, and GeometryCollection. Next to a geometry, simple features can also have non-spatial attributes that describe the feature.\nGeospatial data often comes in tabular format, with one or more columns with feature geometries and additional columns with feature attributes. The Arrow columnar memory model is well-suited to store both vector features and their attribute data. The GeoArrow specification defines how the vector features (geometries) can be stored in Arrow (and Arrow-compatible) data structures.\nThis repository contains the specifications for:\nDefining a standard and efficient way to store geospatial data in the Arrow memory layout enables interoperability between different tools and ensures geospatial tools can leverage the growing Apache Arrow ecosystem:"
  },
  {
    "objectID": "index.html#relationship-with-geoparquet",
    "href": "index.html#relationship-with-geoparquet",
    "title": "GeoArrow",
    "section": "Relationship with GeoParquet",
    "text": "Relationship with GeoParquet\nThe GeoParquet specification originally started in this repo, but was moved out into its own repo (https://github.com/opengeospatial/geoparquet), leaving this repo to focus on the Arrow-specific specifications (Arrow layout and extension type metadata). Whereas GeoParquet is a file-level metadata specification, GeoArrow is a field-level metadata and memory layout specification that applies in-memory (e.g., an Arrow array), on disk (e.g., using Parquet readers/writers provided by an Arrow implementation), and over the wire (e.g., using the Arrow IPC format)."
  },
  {
    "objectID": "index.html#implementations",
    "href": "index.html#implementations",
    "title": "GeoArrow",
    "section": "Implementations",
    "text": "Implementations\n\ngeoarrow-c: geospatial type system and generic coordinate-shuffling library written in C with bindings in C++, R, and Python\ngeoarrow-rs: Rust implementation of the GeoArrow specification and bindings to GeoRust algorithms for efficient spatial operations on GeoArrow memory. Includes JavaScript (WebAssembly) bindings.\ngeoarrow-python: Python bindings to geoarrow-c and geoarrow-rs that provide integrations with libraries like pyarrow, pandas, and geopandas.\ngeoarrow-wasm: WebAssembly module based on geoarrow-rs"
  }
]