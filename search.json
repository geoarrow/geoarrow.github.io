[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Fast, Elegant, and Performative Geospatial Data Analysis with Arrow (Kae Suarez, Dewey Dunnington: Voltron Data Blog)"
  },
  {
    "objectID": "resources.html#blog-posts",
    "href": "resources.html#blog-posts",
    "title": "Resources",
    "section": "",
    "text": "Fast, Elegant, and Performative Geospatial Data Analysis with Arrow (Kae Suarez, Dewey Dunnington: Voltron Data Blog)"
  },
  {
    "objectID": "news/index.html",
    "href": "news/index.html",
    "title": "News",
    "section": "",
    "text": "GeoArrow 0.2 Release\n\n\n\n\n\n\n\n\nMay 27, 2025\n\n\nDewey Dunnington, Kyle Barron, Joris Van den Bossche\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "format.html",
    "href": "format.html",
    "title": "Format",
    "section": "",
    "text": "Format version 0.2.\nSpatial information can be represented as a collection of discrete objects using points, lines, and polygons (i.e., vector data). The Simple Feature Access standard provides a widely used abstraction, defining a set of geometries: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection. Next to a geometry, simple features can also have non-spatial attributes that describe the feature.\nThe Apache Arrow project specifies a standardized language-independent columnar memory format. It enables shared computational libraries, zero-copy shared memory and streaming messaging, interprocess communication, etc and is supported by many programming languages. The Arrow columnar memory model is suited to store both vector features and their attribute data. This document specifies how such vector features can be stored in Arrow (and Arrow-compatible) data structures.\nThe terminology for array types in this document is based on the Arrow Columnar Format specification."
  },
  {
    "objectID": "format.html#native-encoding",
    "href": "format.html#native-encoding",
    "title": "Format",
    "section": "Native encoding",
    "text": "Native encoding\n\nMotivation\nStandard ways to represent or serialize vector geometries include WKT (e.g., “POINT (0 0)”), WKB and GeoJSON. Each of those representations have a considerable (de)serialization cost, neither do they have a compute-friendly memory layout.\nThe goal of this specification is to store geometries in an Arrow-compatible format that:\n\nHas low (de)serialization overhead, and\nOnce in memory is cheap to convert to geospatial libraries (e.g., GEOS or JTS) or easy to directly operate on (e.g., directly working with the coordinate values).\n\nBenefits of using the proposed Arrow-native format include:\n\nCheap access to the raw coordinate values for all geometries,\nColumnar data layout, and\nFull data type system of Arrow is available for attribute data.\n\nMore specifically, the Arrow geometry specification stores the raw coordinate values in contiguous buffers with enough metadata (offsets) to reconstruct or interpret them as actual geometries.\nFlatGeoBuf is similar on various aspects, but is record-oriented, whereas Arrow is column-oriented.\n\n\nMemory layouts\nGeoArrow proposes a packed columnar data format for the fundamental geometry types using packed coordinate and offset arrays to define geometry objects.\nThe inner level is always an array of coordinates. For any geometry type except Point, this inner level is nested in one or multiple variable sized list arrays. In practice, this means we have additional arrays storing the offsets that denote where a new geometry, a new geometry part, or a new polygon ring starts.\nThis specification supports coordinates encoded as a Struct array storing the coordinate values as separate arrays (i.e., x: [x, x, ...], y: [y, y, y, ...]) and a FixedSizeList of interleaved values (i.e., [x, y, x, y, ...]). As implementations evolve, this specification may grow to support other coordinate representations or shrink to support only one if supporting multiple representations becomes a barrier to adoption.\n\nCoordinate\nGeoArrow supports two coordinate representations, separated and interleaved, for maximum compatibility with how different systems may wish to store coordinates.\nWhile both coordinate representations are supported, the separated representation is recommended for most use cases.\n\nCoordinate (separated)\nStruct&lt;x: double, y: double, [z: double, [m: double&gt;]]\nAn array of coordinates can be stored as a Struct array containing two or more child double arrays with names corresponding to the dimension represented by the child. The first and second child arrays must represent the x and y dimension; where z and m dimensions are both included, the z dimension must preceed the m dimension.\n\n\nCoordinate (interleaved)\nFixedSizeList&lt;double&gt;[n_dim]\nAn array of coordinates may also be represented by a single array of interleaved coordinates. n_dim can be 2, 3, or 4 depending on the dimensionality of the geometries, and the field name of the list should be “xy”, “xyz” or “xyzm”, reflecting the dimensionality.\n\n\n\nPoint\nCoordinate\nAn array of point geometries is represented as an array of coordinates, which may be encoded according to either of the options above.\n\n\nLineString\nList&lt;Coordinate&gt;\nAn array of LineStrings is represented as a nested list array with one level of outer nesting: each element of the array (LineString) is a list of coordinate vertices. The child name of the outer list should be “vertices”.\n\n\nPolygon\nList&lt;List&lt;Coordinate&gt;&gt;\nAn array of Polygons is represented as a nested list array with two levels of outer nesting: each element of the array (Polygon) is a list of rings (the first ring is the exterior ring, optional subsequent rings are interior rings), and each ring is a list of coordinate vertices. The child name of the outer list should be “rings”; the child name of the inner list should be “vertices”. The first coordinate and the last coordinate of a ring must be identical (i.e., rings must be closed).\n\n\nMultiPoint\nList&lt;Coordinate&gt;\nAn array of MultiPoints is represented as a nested list array, where each outer list is a single MultiPoint (i.e. a list of coordinates). The child name of the outer List should be “points”.\n\n\nMultiLineString\nList&lt;List&lt;Coordinate&gt;&gt;\nAn array of MultiLineStrings is represented as a nested list array with two levels of outer nesting: each element of the array (MultiLineString) is a list of LineStrings, which consist itself of a list coordinate vertices (see above). The child name of the outer list should be “linestrings”; the child name of the inner list should be “vertices”.\n\n\nMultiPolygon\nList&lt;List&lt;List&lt;Coordinate&gt;&gt;&gt;\nAn array of MultiPolygons is represented as a nested list array with three levels of outer nesting: each element of the array (MultiPolygon) is a list of Polygons, which consist itself of a list of rings (the first ring is the exterior ring, optional subsequent rings are interior rings), and each ring is a list of coordinate vertices. The child name of the outer list should be “polygons”; the child name of the middle list should be “rings”; the child name of the inner list should be “vertices”.\n\n\nGeometryCollection\nList&lt;DenseUnion&gt;&gt;\nAn array of GeometryCollections is represented as a list of a dense union array. In order to explicitly deny support for recursive geometry collections, this definition is not made in terms of the above Geometry array, but re-defines the internal union explicitly.\n\nThe valid “type ids” and field name of the union field metadata must be defined as follows:\n\n\n\nType ID\nGeometry type\nField name\n\n\n\n\n1\nPoint\n\"Point\"\n\n\n2\nLineString\n\"LineString\"\n\n\n3\nPolygon\n\"Polygon\"\n\n\n4\nMultiPoint\n\"MultiPoint\"\n\n\n5\nMultiLineString\n\"MultiLineString\"\n\n\n6\nMultiPolygon\n\"MultiPolygon\"\n\n\n11\nPoint Z\n\"Point Z\"\n\n\n12\nLineString Z\n\"LineString Z\"\n\n\n13\nPolygon Z\n\"Polygon Z\"\n\n\n14\nMultiPoint Z\n\"MultiPoint Z\"\n\n\n15\nMultiLineString Z\n\"MultiLineString Z\"\n\n\n16\nMultiPolygon Z\n\"MultiPolygon Z\"\n\n\n21\nPoint M\n\"Point M\"\n\n\n22\nLineString M\n\"LineString M\"\n\n\n23\nPolygon M\n\"Polygon M\"\n\n\n24\nMultiPoint M\n\"MultiPoint M\"\n\n\n25\nMultiLineString M\n\"MultiLineString M\"\n\n\n26\nMultiPolygon M\n\"MultiPolygon M\"\n\n\n31\nPoint ZM\n\"Point ZM\"\n\n\n32\nLineString ZM\n\"LineString ZM\"\n\n\n33\nPolygon ZM\n\"Polygon ZM\"\n\n\n34\nMultiPoint ZM\n\"MultiPoint ZM\"\n\n\n35\nMultiLineString ZM\n\"MultiLineString ZM\"\n\n\n36\nMultiPolygon ZM\n\"MultiPolygon ZM\"\n\n\n\nThe union array may not contain more than one child array of a given geometry type. All child arrays of the union array must have the same dimensionality and edge type. So Point and Polygon arrays may both be children, but neither Point and Point Z, nor Point and Polygon Z arrays are permitted to be combined.\n\n\n\nGeometry\nDenseUnion\nSo far, all geometry array types listed above have required that all geometries in the array be of the same type. An array of mixed geometry type is represented as a dense union whose children include zero or more of the above geometry array types.\nThe geometry array allows for elements in the array to be of different geometry types; however, all child types must have the same edge type.\n\nThe “type ids” and field name of the union field metadata must be defined as such:\n\n\n\nType ID\nGeometry type\nField name\n\n\n\n\n1\nPoint\n\"Point\"\n\n\n2\nLineString\n\"LineString\"\n\n\n3\nPolygon\n\"Polygon\"\n\n\n4\nMultiPoint\n\"MultiPoint\"\n\n\n5\nMultiLineString\n\"MultiLineString\"\n\n\n6\nMultiPolygon\n\"MultiPolygon\"\n\n\n7\nGeometryCollection\n\"GeometryCollection\"\n\n\n11\nPoint Z\n\"Point Z\"\n\n\n12\nLineString Z\n\"LineString Z\"\n\n\n13\nPolygon Z\n\"Polygon Z\"\n\n\n14\nMultiPoint Z\n\"MultiPoint Z\"\n\n\n15\nMultiLineString Z\n\"MultiLineString Z\"\n\n\n16\nMultiPolygon Z\n\"MultiPolygon Z\"\n\n\n17\nGeometryCollection Z\n\"GeometryCollection Z\"\n\n\n21\nPoint M\n\"Point M\"\n\n\n22\nLineString M\n\"LineString M\"\n\n\n23\nPolygon M\n\"Polygon M\"\n\n\n24\nMultiPoint M\n\"MultiPoint M\"\n\n\n25\nMultiLineString M\n\"MultiLineString M\"\n\n\n26\nMultiPolygon M\n\"MultiPolygon M\"\n\n\n27\nGeometryCollection M\n\"GeometryCollection M\"\n\n\n31\nPoint ZM\n\"Point ZM\"\n\n\n32\nLineString ZM\n\"LineString ZM\"\n\n\n33\nPolygon ZM\n\"Polygon ZM\"\n\n\n34\nMultiPoint ZM\n\"MultiPoint ZM\"\n\n\n35\nMultiLineString ZM\n\"MultiLineString ZM\"\n\n\n36\nMultiPolygon ZM\n\"MultiPolygon ZM\"\n\n\n37\nGeometryCollection ZM\n\"GeometryCollection ZM\"\n\n\n\nThese type id values were chosen to match the WKB specification exactly for 2D geometries and match the WKB specification conceptually for Z, M, and ZM geometries, given the constraint that an Arrow union type ID must be between 0 and 127.\nA geometry array does not need to contain all possible child arrays, but the child arrays that it does contain must have the type ids defined above.\nChild arrays of a geometry array do not need to have the same dimensionality. It will often be easier in practice to store only data of a single dimension, but allowing the geometry array concept to store any mix of types and dimensions enables a static schema for unknown input data.\nThe child arrays should not themselves contain GeoArrow metadata. Only the top-level geometry array should contain GeoArrow metadata.\nGeometryCollections are allowed as children to make this Geometry array the most general of all geometry types.\nAny geometries stored in GeometryCollection children will not be stored in contiguous memory with other children. For example, any points within the GeometryCollection child will not be contiguous with the Point child. If not needed, avoid storing data in GeometryCollection children for best performance.\n\nNote that single and multi geometries of the same type can be stored together in a Multi encoding without using this geometry type. For example, a mix of Polygon and MultiPolygon can be stored as MultiPolygons, with a Polygon being represented as a length-1 MultiPolygon. This is recommended over a geometry array if possible because it has less overhead per geometry.\n\n\nBox\nStruct&lt;xmin: double, ymin: double, [zmin: double, [mmin: double&gt;]], xmax: double, ymax: double, [zmax: double, [mmax: double&gt;]]\nAn array of axis-aligned rectangles is represented as a Struct array containing four, six, or eight child double arrays with names corresponding to the dimension represented by the child. This was chosen to align with the covering column definition in the GeoParquet specification.\nThe child fields MUST be named and ordered as follows for the given dimension:\n\nXY: [xmin, ymin, xmax, ymax]\nXYZ: [xmin, ymin, zmin, xmax, ymax, zmax]\nXYM: [xmin, ymin, mmin, xmax, ymax, mmax]\nXYZM: [xmin, ymin, zmin, mmin, xmax, ymax, zmax, mmax]\n\nThese bounds refer to a set of points such that a value v intersects a box if v &gt;= vmin AND v &lt;= vmax for v in [x, y, z, m].\nIf xmin &gt; xmax, a box may intersect a value x if x &gt;= xmin OR x &lt;= xmax. This behaviour is designed to support compact bounds for geometries that happen to straddle the antimeridian. This behaviour ensures that a GeoJSON bounding box, a GeoParquet file metadata bounding box (also based on GeoJSON), and a box derived from the Iceberg 3.0 specification for geometry and geography column statistics may be expressed as a GeoArrow Box without inspecting values. This exception does not apply to dimensions other than x.\nEmpty ranges may be expressed by setting the min value to infinity and the max value to -infinity for any dimension.\n\n\n\nMissing values (nulls)\nArrow supports missing values through a validity bitmap, and for nested data types every level can be nullable. For this specification, only the outer level is allowed to have nulls, and all other levels (including the inner level with the actual coordinate values) should not contain any nulls. Those fields SHOULD be marked explicitly as non-nullable.\nIn practice this means you can have a missing geometry, but not a geometry with a null part or null (co)ordinate (for example, a polygon with a null ring or a point with a null x value).\n\n\nEmpty geometries\nExcept for Points, empty geometries can be faithfully represented as an empty outer list.\nEmpty points can be represented as POINT (NaN NaN).\n\n\nField and child names\nAll geometry types should have field and child names as suggested for each; however, implementations must be able to ingest arrays with other names when the interpretation is unambiguous (e.g., for xy and xyzm interleaved coordinate interpretations).\n\n\nList types\nArrow has multiple list types, including List (parameterized by int32 offsets), LargeList (parameterized by int64 offsets), and newer ListView and LargeListView.\nImplementations SHOULD accept LargeList int64 offset buffers but MAY produce only List int32 offset buffers.\nThe List type will not overflow until there are 2^31 + 1 entries in the coordinates array. For two 8-byte floats, this would require 32GB of memory in a single coordinates array, and is thus unlikely to occur often in practice."
  },
  {
    "objectID": "format.html#serialized-encodings",
    "href": "format.html#serialized-encodings",
    "title": "Format",
    "section": "Serialized encodings",
    "text": "Serialized encodings\nWhereas there are many advantages to storing data in the native encoding, many producers of geospatial data (e.g., database drivers, file readers) do not have a full geospatial stack at their disposal. The serialized encodings are provided to accomodate these producers and provide every opportunity to propagate critical metadata (e.g., CRS).\n\nWell-known binary (WKB): Binary, LargeBinary, or BinaryView\nIt may be useful for implementations that already have facilities to read and/or write well-known binary (WKB) to store features in this form without modification. For maximum compatibility producers should write ISO-flavoured WKB where possible; however, consumers may accept EWKB or ISO flavoured WKB. Consumers may ignore any embedded SRID values in EWKB.\nThe Arrow Binary type is composed of two buffers: a buffer of int32 offsets and a uint8 data buffer. The LargeBinary type is composed of an int64 offset buffer and a uint8 data buffer.\n\n\nWell-known text (WKT): Utf8, LargeUtf8, or Utf8View\nIt may be useful for implementations that already have facilities to read and/or write well-known text (WKT) to store features in this form without modification.\nThe Arrow Utf8 type is composed of two buffers: a buffer of int32 offsets and a char data buffer. The LargeUtf8 type is composed of an int64 offset buffer and a char data buffer."
  },
  {
    "objectID": "format.html#concrete-examples-of-the-memory-layout",
    "href": "format.html#concrete-examples-of-the-memory-layout",
    "title": "Format",
    "section": "Concrete examples of the memory layout",
    "text": "Concrete examples of the memory layout\nPoint\nArrow type: FixedSizeList&lt;double&gt;[2] or Struct&lt;x: double, y: double&gt;\nFor an array of Point geometries, only a single coordinate array is used. If using a fixed size list coordinate representation, each Point will consist of 2 coordinate values and a single array of length 2*N is sufficiently informative. If using a struct coordinate representation, there will be one child array per dimension.\nExample of array with 3 points:\nWKT: [\"POINT (0 0)\", \"POINT (0 1)\", \"POINT (0 2)\"]\nLogical representation:\n[(0, 0), (0, 1), (0, 2)]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0]\n\nIf using a struct coordinate representation:\n\nCoordinate x values: [0.0, 0.0, 0.0]\nCoordinate y values: [0.0, 1.0, 2.0]\n\nMultiPoint\nArrow type: List&lt;FixedSizeList&lt;double&gt;[2]&gt; or List&lt;Struct&lt;x: double, y: double&gt;&gt;\nFor an array of MultiPoint geometries, an additional array of offsets indicate where the vertices of each MultiPoint start.\nExample of array with 3 multipoints:\nWKT: [\"MULTIPOINT (0 0, 0 1, 0 2)\", \"MULTIPOINT (1 0, 1 1)\", \"MULTIPOINT (2 0, 2 1, 2 2)\"]\nLogical representation:\n[\n    [(0.0, 0.0), (0.0, 1.0), (0.0, 2.0)],\n    [(1.0, 0.0), (1.0, 1.0)],\n    [(2.0, 0.0), (2.0, 1.0), (2.0, 2.0)]\n]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 2.0]\nGeometry offsets: [0, 3, 5, 8]\n\nFor an interleaved coordinate representation, the coordinates buffer must contain the number of geometry offsets * 2 elements. If using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nMultiLineString\nArrow type: List&lt;List&lt;FixedSizeList&lt;double&gt;[2]&gt;&gt; or List&lt;List&lt;Struct&lt;x: double, y: double&gt;&gt;&gt;\nExample of array with 3 multilines:\nWKT:\n[\n    \"LINESTRING (0 0, 0 1, 0 2)\",\n    \"MULTILINESTRING ((1 0, 1 1), (2 0, 2 1, 2 2))\",\n    \"LINESTRING (3 0, 3 1)\"\n]\nLogical representation:\n[\n    [[(0, 0), (0, 1), (0, 2)]],\n    [\n        [(1, 0), (1, 1)],\n        [(2, 0), (2, 1), (2, 2)]\n    ],\n    [[(3, 0), (3, 1)]],\n]\nPhysical representation (buffers):\n\nCoordinates: [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 2.0, 3.0, 0.0, 3.0, 1.0]\nPart offsets (linestrings): [0, 3, 5, 8, 10]\nGeometry offsets: [0, 1, 3, 4]\n\nIf using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nMultiPolygon\nArrow type: List&lt;List&lt;List&lt;FixedSizeList&lt;double&gt;[2]&gt;&gt;&gt; or List&lt;List&lt;List&lt;Struct&lt;x: double, y: double&gt;&gt;&gt;&gt;\nExample of array with 3 points:\nWKT:\n[\n    \"MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))\",\n    \"POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))\",\n    \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)))\"\n]\nLogical representation:\n[\n    # MultiPolygon 1\n    [\n        [\n            [[40, 40], [20, 45], [45, 30], [40, 40]]\n        ],\n        [\n            [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]],\n            [[30, 20], [20, 15], [20, 25], [30, 20]]\n        ]\n    ],\n    # MultiPolygon 2 (using an additional level of nesting to turn the Polygon into a MultiPolygon with one part)\n    [\n        [\n            [[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]\n        ]\n    ],\n    # MultiPolygon 3\n    [\n        [\n            [[30, 20], [45, 40], [10, 40], [30, 20]]\n        ],\n        [\n            [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n        ]\n    ]\n]\nPhysical representation (buffers):\n\nCoordinates: [40.0, 40.0, 20.0, 45.0, 45.0, 30.0, 40.0, 40.0, 20.0, 35.0, 10.0, 30.0, 10.0, 10.0, 30.0, 5.0, 45.0, 20.0, 20.0, 35.0, 30.0, 20.0, 20.0, 15.0, 20.0, 25.0, 30.0, 20.0, 30.0, 10.0, 40.0, 40.0, 20.0, 40.0, 10.0, 20.0, 30.0, 10.0, 30.0, 20.0, 45.0, 40.0, 10.0, 40.0, 30.0, 20.0, 15.0, 5.0, 40.0, 10.0, 10.0, 20.0, 5.0, 10.0, 15.0, 5.0]\nRing offsets: [0, 4, 10, 14, 19, 23, 28]\nPart offsets (polygons): [0, 1, 3, 4, 5, 6]\nGeometry offsets: [0, 2, 3, 5]\n\nIf using a struct coordinate representation, the coordinates buffer would be replaced by two buffers containing coordinate x and coordinate y values.\nWKT\nArrow type: Utf8\nFor an array of WKT geometries, a buffer of offsets indicate where the text of each feature begins.\nExample of array with 2 features:\nWKT: [\"MULTIPOINT (0 0, 0 1)\", \"POINT (30 10)\"]\nLogical representation:\n[\n    \"MULTIPOINT (0 0, 0 1)\",\n    \"POINT (30 10)\"\n]\nPhysical representation (buffers):\n\nData: b\"MULTIPOINT (0 0, 0 1)POINT (30 10)\"\nFeature offsets: [0, 21, 46]"
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data",
    "section": "",
    "text": "The Nova Scotia Water data set (i.e., the Nova Scotia Hydrographic Network) and supporting data are provided by the Nova Scotia Geospatial Data Directory. This data includes Z values and is an example of data distributed through a mainstream channel that requires more than one identifier to capture the CRS (horizontal + vertical CRS identifiers).\nThese data were obtained under an Unrestricted Data Use License Agreement for Government Geographic Data as specified by the Province of Nova Scotia Geospatial Data Directory.\n\n\n\n\nelevation (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nland-poly (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-junc (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-line (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-point (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-poly (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)"
  },
  {
    "objectID": "data.html#nova-scotia-water",
    "href": "data.html#nova-scotia-water",
    "title": "Data",
    "section": "",
    "text": "The Nova Scotia Water data set (i.e., the Nova Scotia Hydrographic Network) and supporting data are provided by the Nova Scotia Geospatial Data Directory. This data includes Z values and is an example of data distributed through a mainstream channel that requires more than one identifier to capture the CRS (horizontal + vertical CRS identifiers).\nThese data were obtained under an Unrestricted Data Use License Agreement for Government Geographic Data as specified by the Province of Nova Scotia Geospatial Data Directory.\n\n\n\n\nelevation (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nland-poly (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-junc (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-line (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-point (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\nwater-poly (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)"
  },
  {
    "objectID": "data.html#microsoft-u.s.-building-footprints",
    "href": "data.html#microsoft-u.s.-building-footprints",
    "title": "Data",
    "section": "Microsoft U.S. Building Footprints",
    "text": "Microsoft U.S. Building Footprints\nThe Microsoft U.S. Building Footprints data set is a collection of ~130 million polygon outlines of buildings derived from satellite imagery. The version of the data set in this repository is does not include Alaska or Hawaii, is repackaged as a single point for each building, and compressed using ZSTD compression to minimize file size and facilitate downloading.\nThe original data is licensed under the Open Data Commons Open Database License (ODbL) and is made available here under the same license.\n\n\nFiles\n\npoint (fgb/zip, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)"
  },
  {
    "objectID": "data.html#natural-earth",
    "href": "data.html#natural-earth",
    "title": "Data",
    "section": "Natural Earth",
    "text": "Natural Earth\nSelected data from Natural Earth. Notably, cities and countries as examples of global data. The countries-geography data includes polygons that cover the antimeridian (e.g., Fiji, Russia) and a pole (e.g., Antarctica); the countries-bounds data includes two boxes that straddle the antimeridian using xmax &lt; xmin behaviour.\nAll versions of Natural Earth map data redistributed here are in the public domain.\n\n\nFiles\n\ncities (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\ncountries (fgb, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\ncountries-geography (arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)\ncountries-bounds (fgb, arrows, arrows/box, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)"
  },
  {
    "objectID": "data.html#usgs-quadrangles",
    "href": "data.html#usgs-quadrangles",
    "title": "Data",
    "section": "USGS Quadrangles",
    "text": "USGS Quadrangles\nQuadrangle map areas from the United States Geological Survey (USGS). These are primarily intended to serve as a non-trivial example of the “box” data type, as map quadrangles are bounded by straight lines in longitude/latitude space.\nThese data were obtained from ESRI and are redistributable without a Value-Added Software Application (such as, adding the sample data to an existing, non-commercial dataset for redistribution) with proper metadata and source/copyright attribution to the United States Geological Survey (USGS).\n\n\nFiles\n\n100k (fgb, arrows/box, arrows, arrows/interleaved, arrows/wkb, geoparquet, geoparquet/native, parquet)"
  },
  {
    "objectID": "data.html#crs-examples",
    "href": "data.html#crs-examples",
    "title": "Data",
    "section": "CRS Examples",
    "text": "CRS Examples\nThe data here is a single polygon representing the outline of the U.S. State of Vermont (as sourced from Natural Earth level 1 administrative boundary data) with various coordinate reference systems (CRS) and various CRS representations. The CRS values used are:\n\nOGC:CRS84: Longitude/latitude on the WGS84 ellipsoid with the axis order of the coordinates specified as such.\nEPSG:4326: Latitude/longitude on the WGS84 ellipsoid. While the stated axis order according to the CRS definition in latitude, longitude; the GeoArrow and GeoParquet standards requires that consumers and producers write longitude, latitude. This is sometimes called “natural” or “traditional GIS” order and is the most common way that data declared as EPSG:4326 is found in the wild.\nUTM Zone 18N: Projected coordinates in universal transverse mercator (i.e., EPSG:32620)\nCustom orthographic: An orthographc projection centred on the centroid of the state of Vermont that does not have any identifier in any database.\n\nThe above examples are all specified with an explicit \"crs_type\": \"projjson\" when written in GeoArrow format. The OGC:CRS84 version of the data is also included using the CRS representations stated in the GeoArrow specification (wkt2:2019, authority_code, and omitted to indicate that the producer did not know what the CRS encoding was).\nAll versions of Natural Earth map data redistributed from this repository are in the public domain.\n\n\nFiles\n\nvermont-crs84 (arrows/wkb, geoparquet, fgb, parquet)\nvermont-4326 (arrows/wkb, geoparquet, fgb, parquet)\nvermont-utm (arrows/wkb, geoparquet, fgb, parquet)\nvermont-custom (arrows/wkb, geoparquet, fgb, parquet)\nvermont-crs84-wkt2 (arrows/wkb, parquet)\nvermont-crs84-auth-code (arrows/wkb, parquet)\nvermont-crs84-unknown (arrows/wkb, parquet)"
  },
  {
    "objectID": "data.html#examples",
    "href": "data.html#examples",
    "title": "Data",
    "section": "Examples",
    "text": "Examples\nThese files are toy example files useful for testing and simple examples. Their main purpose is to make it easy to test full coverage of the geometry type/dimension/coordinate type grid. The examples are based on the wk R package’s wk::wk_example_wkt data set.\n\n\nFiles\n\ngeometry (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\npoint (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nlinestring (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\npolygon (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipoint (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultilinestring (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipolygon (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\ngeometrycollection (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometrycollection-nested (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometry-z (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\npoint-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nlinestring-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\npolygon-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipoint-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultilinestring-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipolygon-z (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\ngeometrycollection-z (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometrycollection-nested-z (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometry-m (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\npoint-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nlinestring-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\npolygon-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipoint-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultilinestring-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipolygon-m (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\ngeometrycollection-m (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometrycollection-nested-m (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometry-zm (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\npoint-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nlinestring-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\npolygon-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipoint-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultilinestring-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\nmultipolygon-zm (tsv, arrows, arrows/interleaved, arrows/wkt, arrows/wkb, parquet, geoparquet, geoparquet/native)\ngeometrycollection-zm (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometrycollection-nested-zm (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)\ngeometry-mixed-dimensions (tsv, arrows/wkt, arrows/wkb, parquet, geoparquet)"
  },
  {
    "objectID": "extension-types.html",
    "href": "extension-types.html",
    "title": "Metadata",
    "section": "",
    "text": "Format version 0.2.\nThe memory layout specification provides an encoding for geometry types using the Arrow Columnar format; however, it does not provide a route by which columns can be recognized as geometry columns when interacting with Arrow bindings (e.g., Arrow C++, PyArrow, or the arrow package for R). Similarly, it does not provide a route by which geometry metadata (e.g., coordinate reference system) can be attached at the column level. Whereas the GeoParquet metadata standard defines table-level metadata intended for geospatial-aware consumers of a file, this specification defines Array-level metadata intended for geospatial-aware consumers of individual Arrays (e.g., a library implementing a geospatial algorithm) or for non-geospatial aware consumers of a table containing such an Array (e.g., a compute engine that can select columns and/or filter rows).\nArrow’s concept of extension types allows types with additional semantics to be built on top of a built-in Arrow data type. Extension types are implemented using two metadata fields: ARROW:extension:name and ARROW:extension:metadata. Whereas the built-in Arrow data types used to store geometry is defined in the memory format specification, this document specifies how the name and metadata should be set to communicate additional information."
  },
  {
    "objectID": "extension-types.html#extension-names",
    "href": "extension-types.html#extension-names",
    "title": "Metadata",
    "section": "Extension names",
    "text": "Extension names\nWhen GeoArrow-encoded Arrays have the ARROW:extension:name metadata field set, it should be set to one of:\n\ngeoarrow.point\ngeoarrow.linestring\ngeoarrow.polygon\ngeoarrow.multipoint\ngeoarrow.multilinestring\ngeoarrow.multipolygon\ngeoarrow.geometry\ngeoarrow.geometrycollection\ngeoarrow.box\ngeoarrow.wkb\ngeoarrow.wkt\n\nThese names correspond to the memory layouts and value constraints described in GeoArrow memory layout specification; however, it should be noted that multiple concrete memory layouts exist for each extension name. The ARROW:extension:name and ARROW:extension:metadata metadata fields must only be set for the Array at the top level (i.e., child arrays must not carry an extension name or metadata)."
  },
  {
    "objectID": "extension-types.html#extension-metadata",
    "href": "extension-types.html#extension-metadata",
    "title": "Metadata",
    "section": "Extension metadata",
    "text": "Extension metadata\nWhen GeoArrow-encoded Arrays have the ARROW:extension:metadata metadata field set, it must be serialized as a UTF-8 encoded JSON object. The extension metadata specification is intentionally aligned with the GeoParquet column metadata specifification. The following keys in the JSON metadata object are supported:\n\ncrs: One of:\n\nA JSON object describing the coordinate reference system (CRS) using PROJJSON.\nA string containing a serialized CRS representation. This option is intended as a fallback for producers (e.g., database drivers or file readers) that are provided a CRS in some form but do not have the means to convert it to PROJJSON.\nOmitted, indicating that the producer does not have any information about the CRS.\n\nFor maximum compatibility, producers should write PROJJSON. Producers should not write an escaped JSON object to the crs key (i.e., when serializing an unknown string to the crs key, producers should check for a valid JSON object and should not escape the input and write it as a string).\nNote that regardless of the axis order specified by the CRS, axis order will be interpreted according to the wording in the GeoPackage WKB binary encoding: axis order is always (longitude, latitude) and (easting, northing) regardless of the the axis order encoded in the CRS specification.\ncrs_type: An optional string disambiguating the value of the crs field. Must be omitted or a string value of:\n\n\"projjson\": Indicates that the \"crs\" field was written as PROJJSON.\n\"wkt2:2019\": Indicates that the \"crs\" field was written as WKT2:2019.\n\"authority_code\": Indicates that the \"crs\" field contains an identifier in the form AUTHORITY:CODE. This should only be used as a last resort (i.e., producers should prefer writing a complete description of the CRS).\n\"srid\": Indicates that the \"crs\" field contains an opaque identifier that requires the consumer to communicate with the producer outside of this metadata. This should only be used as a last resort for database drivers or readers that have no other option.\n\nThe \"crs_type\" should be omitted if the producer cannot guarantee the validity of any of the above values (e.g., if it just serialized a CRS object specifically into one of these representations).\nedges: An optional JSON string describing the interpretation of edges between explicitly defined vertices. This does not affect format conversions (e.g., parsing geoarrow.wkb as geoarrow.linestring), but does affect distance, intersection, bounding, overlay, length, and area calculations. The edges key must be omitted to indicate planar/linear edges or be one of:\n\n\"spherical\": Edges in the longitude-latitude dimensions follow the shortest distance between vertices approximated as the shortest distance between the vertices on a perfect sphere. This edge interpretation is used by BigQuery Geography, and Snowflake Geography. A common library for interpreting edges in this way is Google’s s2geometry; a common formula for calculating distances along this trajectory is the Haversine Formula.\n\"vincenty\": Edges in the longitude-latitude dimensions follow a path calculated using Vincenty’s formula and the ellipsoid specified by the \"crs\".\n\"thomas\": Edges in the longitude-latitude dimensions follow a path calculated by the fomula in Thomas, Paul D. Spheroidal geodesics, reference systems, & local geometry. US Naval Oceanographic Office, 1970 using the ellipsoid specified by the \"crs\".\n\"andoyer\": Edges in the longitude-latitude dimensions follow a path calculated by the fomula in Thomas, Paul D. Mathematical models for navigation systems. US Naval Oceanographic Office, 1965 using the ellipsoid specified by the \"crs\".\n\"karney\": Edges in the longitude-latitude dimensions follow a path calculated by the fomula in Karney, Charles FF. “Algorithms for geodesics.” Journal of Geodesy 87 (2013): 43-55 and GeographicLib using the ellipsoid specified by the \"crs\". GeographicLib available via modern versions of PROJ.\n\nIf the edges key is omitted, edges will be interpreted following the language of Simple features access:\n\nsimple feature feature with all geometric attributes described piecewise by straight line or planar interpolation between sets of points (Section 4.19).\n\nWhen converting an array from one GeoArrow type to another, the \"edges\" field should be propagated from the source to the destination. For example, when parsing a geoarrow.wkb with \"edges\": \"spherical\" to geoarrow.linestring, the edges key of the destination type should also be \"spherical\".\nIf an implementation only has support for a single edge interpretation (e.g., a library with only planar edge support), an array with a different edge type may be imported without loosing information if the geometries in the array do not contain edges (e.g., geoarrow.point, geoarrow.multipoint, a geoarrow.wkb/geoarrow.wkt that only contains points and multipoints, or any array that only contains empty geometries). For arrays that contain edges, the error introduced by ignoring the original edge interpretation is similar to the error introduced by applying a coordinate transformation to vertices (which is usually small but may be large or create invalid geometries, particularly if vertices are not closely spaced). Ignoring the original edge interpretation will silently introduce invalid and/or misinterpreted geometries for any edge that crosses the antimeridian (i.e., longitude 180/-180) when translating from non-planar to planar edges.\nImplementations may implicitly import arrays with an unsupported edge type if the arrays do not contain edges. Implementations may otherwise import arrays with an unsupported edge type with an explicit opt-in from a user or if accompanied by a prominent warning.\nImplementations of spherical, vincenty, thomas, and andoyer are available via Boost::geometry.\n\nIf all metadata keys are omitted, the ARROW:extension:metadata should also be omitted."
  },
  {
    "objectID": "extension-types.html#concrete-examples-of-extension-type-metadata",
    "href": "extension-types.html#concrete-examples-of-extension-type-metadata",
    "title": "Metadata",
    "section": "Concrete examples of extension type metadata",
    "text": "Concrete examples of extension type metadata\nPoint without CRS\nStorage type without extension: FixedSizeList&lt;xy: double&gt;[2]\nThe metadata for the outer array would be as follows:\n\nARROW:extension:name: geoarrow.point\n\nLineString with CRS\nStorage type without extension: List&lt;vertices: FixedSizeList&lt;xy: double&gt;[2]&gt;\nThe metadata for the outer array would be as follows:\n\nARROW:extension:name: geoarrow.linestring\nARROW:extension:metadata: {\"crs\": {\"$schema\":\"https://proj.org/schemas/v0.4/projjson.schema.json\",\"type\":\"GeographicCRS\",\"name\":\"WGS 84\",\"datum\":{\"type\":\"GeodeticReferenceFrame\",\"name\":\"World Geodetic System 1984\",\"ellipsoid\":{\"name\":\"WGS 84\",\"semi_major_axis\":6378137,\"inverse_flattening\":298.257223563},\"id\":{\"authority\":\"EPSG\",\"code\":6326}},\"coordinate_system\":{\"subtype\":\"ellipsoidal\",\"axis\":[{\"name\":\"Longitude\",\"abbreviation\":\"lon\",\"direction\":\"east\",\"unit\":\"degree\"},{\"name\":\"Latitude\",\"abbreviation\":\"lat\",\"direction\":\"north\",\"unit\":\"degree\"}]}}}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GeoArrow",
    "section": "",
    "text": "Version 0.2.\nThis repository contains a specification for storing geospatial data in Apache Arrow and Arrow-compatible data structures and formats.\nThe Apache Arrow project specifies a standardized language-independent columnar memory format. It enables shared computational libraries, zero-copy shared memory and streaming messaging, interprocess communication, and is supported by many programming languages and data libraries.\nSpatial information can be represented as a collection of discrete objects using points, lines and polygons (i.e., vector data). The Simple Feature Access standard provides a widely used abstraction, defining a set of geometries: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, and GeometryCollection. Next to a geometry, simple features can also have non-spatial attributes that describe the feature.\nGeospatial data often comes in tabular format, with one or more columns with feature geometries and additional columns with feature attributes. The Arrow columnar memory model is well-suited to store both vector features and their attribute data. The GeoArrow specification defines how the vector features (geometries) can be stored in Arrow (and Arrow-compatible) data structures.\nThis repository contains the specifications for:\nDefining a standard and efficient way to store geospatial data in the Arrow memory layout enables interoperability between different tools and ensures geospatial tools can leverage the growing Apache Arrow ecosystem:"
  },
  {
    "objectID": "index.html#relationship-with-geoparquet",
    "href": "index.html#relationship-with-geoparquet",
    "title": "GeoArrow",
    "section": "Relationship with GeoParquet",
    "text": "Relationship with GeoParquet\nThe GeoParquet specification originally started in this repo, but was moved out into its own repo, leaving this repo to focus on the Arrow-specific specifications (Arrow layout and extension type metadata). Whereas GeoParquet is a file-level metadata specification, GeoArrow is a field-level metadata and memory layout specification that applies in-memory (e.g., an Arrow array), on disk (e.g., using Parquet readers/writers provided by an Arrow implementation), and over the wire (e.g., using the Arrow IPC format)."
  },
  {
    "objectID": "index.html#implementations",
    "href": "index.html#implementations",
    "title": "GeoArrow",
    "section": "Implementations",
    "text": "Implementations\n\ngeoarrow-c: geospatial type system and generic coordinate-shuffling library written in C with bindings in C++, R, and Python\ngeoarrow-rs: Rust implementation of the GeoArrow specification and bindings to GeoRust algorithms for efficient spatial operations on GeoArrow memory. See also:\n\nPython bindings to geoarrow-rs\ngeoarrow-wasm, JavaScript (WebAssembly) bindings to geoarrow-rs.\n\ngeoarrow-python: Python bindings to geoarrow-c that provide integrations with libraries like pyarrow, pandas, and geopandas.\ngeoarrow-r: R bindings to geoarrow-c that provide integrations with libraries like sf and Arrow for geospatial data handling.\ngeoarrow-js: Pure TypeScript implementation of GeoArrow, on top of the Arrow JavaScript implementation."
  },
  {
    "objectID": "index.html#downstream-libraries",
    "href": "index.html#downstream-libraries",
    "title": "GeoArrow",
    "section": "Downstream libraries",
    "text": "Downstream libraries\n\nLonboard: fast, interactive geospatial vector data visualization in Jupyter, building on top of GeoArrow."
  },
  {
    "objectID": "news/release-0-2.html",
    "href": "news/release-0-2.html",
    "title": "GeoArrow 0.2 Release",
    "section": "",
    "text": "We released the first version of the GeoArrow specification (v0.1) in September 2023. Since then we’ve learned from the numerous integrations implemented by ourselves and others in the spatial community that highlighted ambiguities in the text of the first version and use-cases that necessitated changes to the specification. In this post we highlight new updates to the specification, updates to implementations, and community-driven integrations since the last specification release."
  },
  {
    "objectID": "news/release-0-2.html#specification",
    "href": "news/release-0-2.html#specification",
    "title": "GeoArrow 0.2 Release",
    "section": "Specification",
    "text": "Specification\nThe GeoArrow specification establishes conventions for representing spatial data in Apache Arrow formats (e.g., C Data Interface, Serialized IPC) and implementations (e.g., PyArrow, Arrow C++, arrow-rs). It is separated into two parts:\n\nA set of memory layouts to represent geometry arrays using features of the Arrow type system/format (e.g., points can be represented as a struct&lt;x: double, y: double&gt;) instead of serialized into well-known binary or some other binary format.\nA set of extension type definitions to propagate type-level spatial metadata (e.g., coordinate reference system, edge interpolation)"
  },
  {
    "objectID": "news/release-0-2.html#notable-changes",
    "href": "news/release-0-2.html#notable-changes",
    "title": "GeoArrow 0.2 Release",
    "section": "Notable changes",
    "text": "Notable changes\nIn addition to some minor updates to improve clarity, GeoArrow 0.2 includes a few notable changes.\n\nNew array types\nThe GeoArrow 0.2 specification formalizes three new array types:\n\nThe Box memory layout represents an array of axis-aligned bounding boxes, represented as an Arrow struct.\nThe Geometry memory layout allows arbitrary geometries to be represented within a single array, even when the geometry type differs across rows. It’s implemented as an Arrow union of the other native encodings.\nThe Geometry Collection memory layout allows arbitrary geometries to be represented within a single feature. It uses an Arrow list around an Arrow union.\n\n\n\nCoordinate Reference System updates\nThe language defining the content of the \"crs\" key in the extension metadata was updated to simplify the dependency requirements of producers that did not have a built-in ability to produce PROJJSON, which was previously the only option allowed by the specification.\nMost producers of GeoArrow metadata have the ability to write PROJJSON and should continue to do so. However, other producers are now allowed to pass on whatever information they do have as a string.\nFor cases where the producer knows exactly how it serializes the CRS, the optional \"crs_type\" field was added and can take on the value \"authority_code\", \"srid\", \"projjson\", or \"wkt2:2019\". Among other use cases, this enabled the C++ implementation of the Parquet GEOMETRY type to losslessly pass on all the information stored in a Parquet logical type annotation for GEOMETRY or GEOGRAPHY in a dependency-sensitive environment.\n\nPROJJSON example\n{\n  \"crs\": {\"$schema\":\"https://proj.org/schemas/v0.7/projjson.schema.json\",\"type\":\"ProjectedCRS\",\"name\":\"WGS 84 / UTM zone 20N\",\"base_crs\":{\"name\":\"WGS 84\",\"datum_ensemble\":{\"name\":\"World Geodetic System 1984 ensemble\",\"members\":[{\"name\":\"World Geodetic System 1984 (Transit)\",\"id\":{\"authority\":\"EPSG\",\"code\":1166}},{\"name\":\"World Geodetic System 1984 (G730)\",\"id\":{\"authority\":\"EPSG\",\"code\":1152}},{\"name\":\"World Geodetic System 1984 (G873)\",\"id\":{\"authority\":\"EPSG\",\"code\":1153}},{\"name\":\"World Geodetic System 1984 (G1150)\",\"id\":{\"authority\":\"EPSG\",\"code\":1154}},{\"name\":\"World Geodetic System 1984 (G1674)\",\"id\":{\"authority\":\"EPSG\",\"code\":1155}},{\"name\":\"World Geodetic System 1984 (G1762)\",\"id\":{\"authority\":\"EPSG\",\"code\":1156}},{\"name\":\"World Geodetic System 1984 (G2139)\",\"id\":{\"authority\":\"EPSG\",\"code\":1309}},{\"name\":\"World Geodetic System 1984 (G2296)\",\"id\":{\"authority\":\"EPSG\",\"code\":1383}}],\"ellipsoid\":{\"name\":\"WGS 84\",\"semi_major_axis\":6378137,\"inverse_flattening\":298.257223563},\"accuracy\":\"2.0\",\"id\":{\"authority\":\"EPSG\",\"code\":6326}},\"coordinate_system\":{\"subtype\":\"ellipsoidal\",\"axis\":[{\"name\":\"Geodetic latitude\",\"abbreviation\":\"Lat\",\"direction\":\"north\",\"unit\":\"degree\"},{\"name\":\"Geodetic longitude\",\"abbreviation\":\"Lon\",\"direction\":\"east\",\"unit\":\"degree\"}]},\"id\":{\"authority\":\"EPSG\",\"code\":4326}},\"conversion\":{\"name\":\"UTM zone 20N\",\"method\":{\"name\":\"Transverse Mercator\",\"id\":{\"authority\":\"EPSG\",\"code\":9807}},\"parameters\":[{\"name\":\"Latitude of natural origin\",\"value\":0,\"unit\":\"degree\",\"id\":{\"authority\":\"EPSG\",\"code\":8801}},{\"name\":\"Longitude of natural origin\",\"value\":-63,\"unit\":\"degree\",\"id\":{\"authority\":\"EPSG\",\"code\":8802}},{\"name\":\"Scale factor at natural origin\",\"value\":0.9996,\"unit\":\"unity\",\"id\":{\"authority\":\"EPSG\",\"code\":8805}},{\"name\":\"False easting\",\"value\":500000,\"unit\":\"metre\",\"id\":{\"authority\":\"EPSG\",\"code\":8806}},{\"name\":\"False northing\",\"value\":0,\"unit\":\"metre\",\"id\":{\"authority\":\"EPSG\",\"code\":8807}}]},\"coordinate_system\":{\"subtype\":\"Cartesian\",\"axis\":[{\"name\":\"Easting\",\"abbreviation\":\"E\",\"direction\":\"east\",\"unit\":\"metre\"},{\"name\":\"Northing\",\"abbreviation\":\"N\",\"direction\":\"north\",\"unit\":\"metre\"}]},\"scope\":\"Navigation and medium accuracy spatial referencing.\",\"area\":\"Between 66°W and 60°W, northern hemisphere between equator and 84°N, onshore and offshore. Anguilla. Antigua and Barbuda. Bermuda. Brazil. British Virgin Islands. Canada - New Brunswick; Labrador; Nova Scotia; Nunavut; Prince Edward Island; Quebec. Dominica. Greenland. Grenada. Guadeloupe. Guyana. Martinique. Montserrat. Puerto Rico. St Kitts and Nevis. St Barthelemy. St Lucia. St Maarten, St Martin. St Vincent and the Grenadines. Trinidad and Tobago. Venezuela. US Virgin Islands.\",\"bbox\":{\"south_latitude\":0,\"west_longitude\":-66,\"north_latitude\":84,\"east_longitude\":-60},\"id\":{\"authority\":\"EPSG\",\"code\":32620}},\n  \"crs_type\": \"projjson\"\n}\nWKT2 example:\n{\n  \"crs\": 'PROJCRS[\"WGS 84 / UTM zone 20N\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 20N\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",-63,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",0,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 66°W and 60°W, northern hemisphere between equator and 84°N, onshore and offshore. Anguilla. Antigua and Barbuda. Bermuda. Brazil. British Virgin Islands. Canada - New Brunswick; Labrador; Nova Scotia; Nunavut; Prince Edward Island; Quebec. Dominica. Greenland. Grenada. Guadeloupe. Guyana. Martinique. Montserrat. Puerto Rico. St Kitts and Nevis. St Barthelemy. St Lucia. St Maarten, St Martin. St Vincent and the Grenadines. Trinidad and Tobago. Venezuela. US Virgin Islands.\"],BBOX[0,-66,84,-60]],ID[\"EPSG\",32620]]',\n  \"crs_type\": \"wkt2:2019\",\n}\nAuthority code example:\n{\n    \"crs\": \"EPSG:32620\",\n    \"crs_type\": \"authority_code\",\n}\nNote that this should only be used as a last resort. Producers should prefer writing a complete description of the CRS.\nSRID example:\n{\n    \"crs\": \"32620\",\n    \"crs_type\": \"srid\",\n}\nNote that this should only be used as a last resort for database drivers or readers that have no other option.\nOpaque CRS example:\n{\n    \"crs\": 'PROJCS[\"WGS 84 / UTM zone 20N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-63],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32620\"]]',\n}\nOpaque CRS strings should only be used as a last resort when the producer has no way to communicate more information. In this case, the CRS is a WKT1 string, which doesn’t fit into any other allowed variants.\n\n\n\nNewly-supported data types for WKT and WKB arrays\nVersion 1.4 of the Arrow Columnar format added “binary view” and “string view” layouts. This new representation for an array of strings or bytes is widely held to be more performant for common use cases.\nGeoArrow 0.2 allows serialized Well-Known Binary (WKB) and Well-Known Text (WKT) arrays to be backed by these new binary view and string view data types.\n\n\nEdge interpolations\nIn the previous version of the specification, the \"edges\" parameter could have been omitted (to indicate planar/linear edges as defined by simple features) or taken the value \"spherical\" to indicate that vertices should be connected by approximating the edge as the shortest path on a perfect sphere. The recently added GEOMETRY and GEOGRAPHY types in Parquet and Iceberg, included four other options to handle Ellipsoidal edges: \"vincenty\", \"thomas\", \"andoyer\", and \"karney\". We also added these to GeoArrow such that it can faithfully represent the intent of an arbitrary Parquet and/or Iceberg source.\n\n\nSuggestion to use separated coordinate layout\nGeoArrow supports two coordinate representations, separated and interleaved, for maximum compatibility with how different systems may wish to store coordinates.\nWhile both coordinate representations continue to be supported, we now recommend the separated representation for most use cases."
  },
  {
    "objectID": "news/release-0-2.html#implementations",
    "href": "news/release-0-2.html#implementations",
    "title": "GeoArrow 0.2 Release",
    "section": "Implementations",
    "text": "Implementations\nSeveral GeoArrow implementations have been updated to support new features in GeoArrow 0.2.\nKeep in mind that the implementation status here is current as of May 2025. If reading this in the future, refer also to individual projects for the most up-to-date information.\n\nRust\ngeoarrow-rs, the Rust implementation of GeoArrow, has been undergoing a large refactor from a single, overly-monolithic crate to a monorepo of smaller crates, each with a more well-defined scope. These smaller crates better communicate which parts of the project are production ready and which parts are more prototypical.\ngeoarrow-rs is now split into the following crates:\n\ngeoarrow-schema: GeoArrow geometry type and metadata definitions.\ngeoarrow-array: GeoArrow array definitions.\ngeoarrow-cast: Functions for converting from one GeoArrow geometry type to another.\n\nThese core crates are relatively stable and support the full GeoArrow 0.2 specification.\nAdditional crates are under development but not quite released for public usage. Native Rust integration with GeoParquet will be released soon. Support for other file formats like FlatGeobuf, GeoJSON, CSV, and Shapefile is under development, as are geometry operations backed by the geo crate or by linking to GEOS.\n\n\nC/C++\nThe geoarrow project also includes C/C++ bindings to produce and consume GeoArrow arrays from C based languages. The scope of geoarrow-c is more limited than that of geoarrow-rust; however, it does include a purpose-built WKT/WKB reader/writer and can cast those to and from native encodings. To maximize usability, geoarrow-c can be amalgamated into a single .c/.h pair depending only on nanoarrow (which also can be amalgamated into a single .c/.h pair).\nThe latest release of geoarrow-c supports the full GeoArrow 0.2 specification (with the exception of union types) and includes experimental new C++ helpers to make it more ergonomic to work with GeoArrow arrays passed over the Arrow C Data Interface in C++.\n\n\nPython\nThe Initial geoarrow-pyarrow implementation depended completely on geoarrow’s C implementation for almost everything; however it quickly became clear that a PyArrow-native implementation was what potential importers/exporters of GeoArrow in Python were actually looking for. The result was two packages:\n\ngeoarrow-types, which provides an pure Python implementation of the GeoArrow type system and PyArrow-native extension type implementation.\ngeoarrow-pyarrow, which provides compute functions and IO tools that use PyArrow data structures for input/output but use various GeoArrow implementations under the hood to do the actual crunching.\n\nThe changes since the 0.1 release were mostly structural; however new spec features were also added including support for the box type and support for non-PROJJSON CRS encodings.\nWhereas geoarrow-pyarrow and geoarrow-types are aimed squarely at the PyArrow ecosystem, geoarrow-rust provides an experimental set of compute and IO functions with input/output based on the Arrow PyCapsule Interface. As the project evolves, we envison synergy among these projects to provide magical interoperability and spatial compute capability to pyarrow users and beyond.\n\n\nR\nThe GeoArrow R bindings provide integration between the r-spatial ecosystem (e.g., the sf package) and the Arrow ecosystems (e.g., the arrow and nanoarrow packages).\nThe latest geoarrow-r release includes updated geoarrow-c internals and support for features of the GeoArrow 0.2 specification (except union types)."
  },
  {
    "objectID": "news/release-0-2.html#data",
    "href": "news/release-0-2.html#data",
    "title": "GeoArrow 0.2 Release",
    "section": "Data",
    "text": "Data\nGeoArrow’s 0.2 series of releases includes brand new revamped example data, the pipeline for which was completely rewritten to be mostly in Python using geoarrow-rs’s excellent Python bindings, geoarrow-python, geopandas, and duckdb-spatial. The new pipeline made it easier to generate more formats and more examples to cover some of the concepts highlighted by our first year of on-the-ground experience with the format. A few highlights include:\n\nMost examples are now available in FlatGeoBuf, GeoParquet’s WKB and Native encodings, Parquet’s brand-new GEOMETRY logical type, and GeoArrow IPC streams with the WKT, WKB, native/interleaved, and native/separated encodings where appropriate.\nCoordinate Reference System (CRS) examples were added to cover various CRS encodings and categories that implementations may wish to consider.\nUSGS Map Quadrangles were added to illustrate the utility of/test the new “box” encoding that was added in the 0.2 release.\nSeveral examples based on the Natural Earth project were added, including an example with spherical edges/geography data type that can be used as a basic example to illustrate/test global data handling.\n\nThe latest data is available from the geoarrow.org data page and the sources can be found at the geoarrow/geoarrow-data GitHub repository."
  },
  {
    "objectID": "news/release-0-2.html#ecosystem",
    "href": "news/release-0-2.html#ecosystem",
    "title": "GeoArrow 0.2 Release",
    "section": "Ecosystem",
    "text": "Ecosystem\n\nGeoPandas\nIn the landmark GeoPandas 1.0 release, the GeoSeries and GeoDataFrame added from_arrow() and to_arrow() methods to import and export Python objects using the Arrow PyCapsule Interface.\nimport pyarrow as pa\nimport geoarrow.pyarrow as ga\nfrom geoarrow.rust.io import read_flatgeobuf\nimport geopandas\n\nurl = \"https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0/natural-earth/files/natural-earth_cities.fgb\"\n\ntable_rs = read_flatgeobuf(url)\ndf = geopandas.GeoDataFrame.from_arrow(table_rs)\ndf.head(5)\n#&gt;            name                   geometry\n#&gt; 0  Vatican City  POINT (12.45339 41.90328)\n#&gt; 1    San Marino   POINT (12.44177 43.9361)\n#&gt; 2         Vaduz   POINT (9.51667 47.13372)\n#&gt; 3       Lobamba     POINT (31.2 -26.46667)\n#&gt; 4    Luxembourg      POINT (6.13 49.61166)\n\npa.table(df.to_arrow())\n#&gt; pyarrow.Table\n#&gt; name: string\n#&gt; geometry: extension&lt;geoarrow.wkb&lt;WkbType&gt;&gt;\n#&gt; ----\n#&gt; name: [[\"Vatican City\",\"San Marino\",\"Vaduz\",\"Lobamba\",\"Luxembourg\",...,\n#&gt; geometry: [[010100000054E57B4622E828408B074AC09EF34440,0101000000DC...\nFor more information, see the excellent GeoPandas documentation:\n\nGeoSeries.from_arrow()\nGeoSeries.to_arrow()\nGeoDataFrame.from_arrow()\nGeoDataFrame.to_arrow()\n\nThanks to @jorisvandenbossche and @kylebarron, for driving this integration!\n\n\nLonboard\nWhat’s a fast geospatial skateboard? A lonboard, of course! Powered by deck.gl, lonboard can effortlessly render millions of features on an interactive map. The rendering is powered by GeoArrow’s native encodings and the GeoArrow extension types power geometry column detection and on-the-fly reprojection to ensure multiple layers are plotted together properly. The viz() one-liner works on any Arrow-ish Python object and is a massive quality-of-life improvement when working with large-ish data in a notebook.\nimport geoarrow.pyarrow.io\nfrom lonboard import viz\n\nurl = \"https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0/natural-earth/files/natural-earth_cities.fgb\"\nviz(geoarrow.pyarrow.io.read_pyogrio_table(url))\n\nAll credit here to @kylebarron for creating and maintaining this tool!\n\n\nDuckDB\nIt has long been a confusion for users of DuckDB’s fantastic spatial extension that a query like SELECT st_geomfromtext('LINESTRING (0 1, 2 3)'), when converted to PyArrow or R’s arrow package, contains no indication of any geometry column. The column that does appear in the output contains DuckDB spatial’s internal serialization and is in general not that useful.\nIn DuckDB 1.2, core developers added support for extensions to control Arrow import/export, which opened the door for the spatial extension to accept GeoArrow extensions and roundtrip the geometry type through DuckDB’s much used Arrow integration in Python, R, and ADBC. Among other libraries supporting GeoArrow, this powers seamless integration between GeoPandas and DuckDB.\nimport geopandas\nimport duckdb\n\nduckdb.load_extension(\"spatial\")\nduckdb.sql(\"CALL register_geoarrow_extensions()\")\n\n# Create a GeoDataFrame\nurl = \"https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0/natural-earth/files/natural-earth_cities.fgb\"\ndf = geopandas.read_file(url)\n\n# Create the Arrow table and use select directly from it with DuckDB\ndf_arrow = df.to_arrow()\nduckdb.sql(\"SELECT * FROM df_arrow\").limit(5)\n#&gt; ┌──────────────┬────────────────────────────────┐\n#&gt; │     name     │            geometry            │\n#&gt; │   varchar    │            geometry            │\n#&gt; ├──────────────┼────────────────────────────────┤\n#&gt; │ Vatican City │ POINT (12.4533865 41.9032822)  │\n#&gt; │ San Marino   │ POINT (12.4417702 43.9360958)  │\n#&gt; │ Vaduz        │ POINT (9.5166695 47.1337238)   │\n#&gt; │ Lobamba      │ POINT (31.1999971 -26.4666675) │\n#&gt; │ Luxembourg   │ POINT (6.1300028 49.6116604)   │\n#&gt; └──────────────┴────────────────────────────────┘\n\n# Going the other direction, call from_arrow() directly on a DuckDB result\ngeopandas.GeoDataFrame.from_arrow(duckdb.sql(\"SELECT * FROM df_arrow\")).head(5)\n#&gt;            name                   geometry\n#&gt; 0  Vatican City  POINT (12.45339 41.90328)\n#&gt; 1    San Marino   POINT (12.44177 43.9361)\n#&gt; 2         Vaduz   POINT (9.51667 47.13372)\n#&gt; 3       Lobamba     POINT (31.2 -26.46667)\n#&gt; 4    Luxembourg      POINT (6.13 49.61166)\nFor several more examples and a deeper dive in to DuckDB spatial in Python, see Max Gabrielsson’s excellent GeoPython 2025 tutorial.\nSpecial thanks to @Maxxen, @pdet, and @ianmcook for the PRs, reviews, and coordination to get this feature over the finish line!\n\n\nApache Sedona\nApache Sedona’s 1.6.0 release added dataframe_to_arrow() in its Python bindings and its 1.7.0 release added an Arrow-powered create_spatial_dataframe() creator to accellerate the Sedona–GeoPandas integration. In addition to better performance when converting between GeoPandas and Spark, this change accellerated visualization of Spark DataFrames with Geometry and general integration with tools that support GeoArrow.\nimport geopandas\nimport lonboard\nfrom sedona.spark import SedonaContext\nfrom sedona.utils.geoarrow import create_spatial_dataframe, dataframe_to_arrow\n\nurl = \"https://raw.githubusercontent.com/geoarrow/geoarrow-data/v0.2.0/natural-earth/files/natural-earth_cities.fgb\"\ndf = geopandas.read_file(url)\n\nconfig = SedonaContext.builder().getOrCreate()\nsedona = SedonaContext.create(config)\n\nsedona_df = create_spatial_dataframe(sedona, df)\nsedona_df.printSchema()\n#&gt; root\n#&gt;  |-- name: string (nullable = true)\n#&gt;  |-- geometry: geometry (nullable = true)\n\nlonboard.viz(dataframe_to_arrow(sedona_df))\n\nThese integrations were made possible by backporting the forthcoming toArrow() in Spark 4.0 and the forthcoming ability of createDataFrame() to accept Arrow objects directly.\nThanks to @ianmcook for driving these changes in the Spark project and thanks to @jiayuasu and @Imbruced for reviewing/integrating these changes into Sedona!\n\n\nGDAL\nGDAL added its first Arrow integration in RFC 86. This integration added a C API to work around the performance limitations of OGR’s row-based reader and was picked up by pyogrio almost immediately to enable faster IO - particularly for GeoPackage and FlatGeoBuf - for geopandas users. About a year later a matching write API was added and was used by GDAL itself to speed up its popular ogr2ogr command-line interface. Most recently, GDAL 3.11.0 added an Arrow Database Connectivity (ADBC) integration to read geometry columns from ADBC-integrated datasources like PostGIS and DuckDB.\nSpecifically related to the GeoArrow specification, GDAL 3.8.0 included the ability to export geometry through its Arrow interface with GeoArrow type and CRS metadata. This makes it substantially easier to propagate the CRS of a geometry column when using OGR’s GetArrowStream() interface by passing the GEOMETRY_METADATA_ENCODING=GEOARROW layer option. When this option is set, geometry columns are marked with the geoarrow.wkb extension type with the appropriate \"crs\" in the extension metadata.\nFull credit to @rouault for implementing these changes in the GDAL project!"
  },
  {
    "objectID": "news/release-0-2.html#whats-next",
    "href": "news/release-0-2.html#whats-next",
    "title": "GeoArrow 0.2 Release",
    "section": "What’s next?",
    "text": "What’s next?\nWe’re thrilled that the GeoArrow specification has unlocked interoperability among spatial libraries and that the specification continues to evolve to serve the needs of the rapidly evolving spatial ecosystem. We’ve had discussions about how to represent raster data and how to integrate discrete global grids like S2 and H3…we look forward to continuing to grow the community and we’re excited to see where it will go!"
  }
]